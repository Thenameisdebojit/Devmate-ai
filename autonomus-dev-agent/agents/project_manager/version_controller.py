"""
Version Controller
Handles Git integration: initialization, commits, and GitHub integration.
"""

from typing import Dict, Any, List, Optional
from pathlib import Path
import logging
import subprocess
import json
from datetime import datetime

logger = logging.getLogger(__name__)


class VersionController:
    """Manages version control with Git integration"""
    
    def __init__(self):
        """Initialize version controller"""
        self.git_available = self._check_git_available()
        logger.info(f"Version Controller initialized (Git available: {self.git_available})")
    
    def _check_git_available(self) -> bool:
        """Check if Git is installed"""
        try:
            result = subprocess.run(
                ["git", "--version"],
                capture_output=True,
                text=True,
                timeout=5
            )
            return result.returncode == 0
        except Exception:
            return False
    
    def _run_git_command(
        self,
        command: List[str],
        cwd: Optional[Path] = None
    ) -> Dict[str, Any]:
        """Run a git command"""
        
        if not self.git_available:
            return {
                "success": False,
                "error": "Git is not available"
            }
        
        try:
            result = subprocess.run(
                ["git"] + command,
                capture_output=True,
                text=True,
                cwd=cwd,
                timeout=30
            )
            
            return {
                "success": result.returncode == 0,
                "stdout": result.stdout.strip(),
                "stderr": result.stderr.strip(),
                "returncode": result.returncode
            }
        
        except subprocess.TimeoutExpired:
            return {
                "success": False,
                "error": "Git command timed out"
            }
        except Exception as e:
            return {
                "success": False,
                "error": str(e)
            }
    
    def initialize_repository(
        self,
        project_path: Path,
        initial_branch: str = "main"
    ) -> Dict[str, Any]:
        """Initialize a Git repository"""
        
        if not project_path.exists():
            project_path.mkdir(parents=True, exist_ok=True)
        
        # Check if already a git repo
        if (project_path / ".git").exists():
            logger.info(f"Git repository already exists at {project_path}")
            return {
                "success": True,
                "already_exists": True
            }
        
        # Initialize repo
        result = self._run_git_command(["init"], cwd=project_path)
        
        if not result["success"]:
            logger.error(f"Failed to initialize Git repository: {result.get('error')}")
            return result
        
        # Set default branch
        branch_result = self._run_git_command(
            ["branch", "-M", initial_branch],
            cwd=project_path
        )
        
        # Create .gitignore
        gitignore_content = """# Dependencies
node_modules/
__pycache__/
*.pyc
.venv/
venv/
env/

# Environment variables
.env
.env.local
.env.*.local

# IDE
.vscode/
.idea/
*.swp
*.swo
.DS_Store

# Build outputs
dist/
build/
*.egg-info/
.next/
out/

# Logs
*.log
logs/

# Testing
coverage/
.pytest_cache/
.coverage

# Misc
.cache/
*.tmp
"""
        
        gitignore_path = project_path / ".gitignore"
        gitignore_path.write_text(gitignore_content, encoding='utf-8')
        
        logger.info(f"Initialized Git repository at {project_path}")
        
        return {
            "success": True,
            "path": str(project_path),
            "branch": initial_branch
        }
    
    def create_initial_commit(
        self,
        project_path: Path,
        message: str = "Initial commit: Generated by Autonomous Deep AI Agent"
    ) -> Dict[str, Any]:
        """Create initial commit with all files"""
        
        # Add all files
        add_result = self._run_git_command(["add", "."], cwd=project_path)
        
        if not add_result["success"]:
            logger.error(f"Failed to add files: {add_result.get('error')}")
            return add_result
        
        # Create commit
        commit_result = self._run_git_command(
            ["commit", "-m", message],
            cwd=project_path
        )
        
        if not commit_result["success"]:
            logger.error(f"Failed to create commit: {commit_result.get('error')}")
            return commit_result
        
        logger.info(f"Created initial commit: {message}")
        
        return {
            "success": True,
            "message": message,
            "output": commit_result["stdout"]
        }
    
    def add_remote(
        self,
        project_path: Path,
        remote_name: str,
        remote_url: str
    ) -> Dict[str, Any]:
        """Add a remote repository"""
        
        result = self._run_git_command(
            ["remote", "add", remote_name, remote_url],
            cwd=project_path
        )
        
        if result["success"]:
            logger.info(f"Added remote '{remote_name}': {remote_url}")
        else:
            logger.error(f"Failed to add remote: {result.get('error')}")
        
        return result
    
    def push_to_remote(
        self,
        project_path: Path,
        remote_name: str = "origin",
        branch: str = "main"
    ) -> Dict[str, Any]:
        """Push to remote repository"""
        
        result = self._run_git_command(
            ["push", "-u", remote_name, branch],
            cwd=project_path
        )
        
        if result["success"]:
            logger.info(f"Pushed to {remote_name}/{branch}")
        else:
            logger.error(f"Failed to push: {result.get('error')}")
        
        return result
    
    def create_github_repo(
        self,
        repo_name: str,
        description: str = "",
        private: bool = False,
        github_token: Optional[str] = None
    ) -> Dict[str, Any]:
        """Create a GitHub repository using GitHub CLI"""
        
        if not github_token:
            return {
                "success": False,
                "error": "GitHub token not provided"
            }
        
        # Check if GitHub CLI is available
        try:
            subprocess.run(
                ["gh", "--version"],
                capture_output=True,
                timeout=5
            )
        except Exception:
            return {
                "success": False,
                "error": "GitHub CLI (gh) is not installed"
            }
        
        # Create repository
        visibility = "--private" if private else "--public"
        
        try:
            result = subprocess.run(
                [
                    "gh", "repo", "create", repo_name,
                    visibility,
                    "--description", description,
                    "--clone=false"
                ],
                capture_output=True,
                text=True,
                timeout=30,
                env={"GH_TOKEN": github_token}
            )
            
            if result.returncode == 0:
                logger.info(f"Created GitHub repository: {repo_name}")
                return {
                    "success": True,
                    "repo_name": repo_name,
                    "output": result.stdout.strip()
                }
            else:
                logger.error(f"Failed to create GitHub repo: {result.stderr}")
                return {
                    "success": False,
                    "error": result.stderr.strip()
                }
        
        except Exception as e:
            return {
                "success": False,
                "error": str(e)
            }
    
    def get_commit_history(
        self,
        project_path: Path,
        limit: int = 10
    ) -> List[Dict[str, str]]:
        """Get commit history"""
        
        result = self._run_git_command(
            ["log", f"-{limit}", "--pretty=format:%H|%an|%ae|%ad|%s"],
            cwd=project_path
        )
        
        if not result["success"]:
            return []
        
        commits = []
        for line in result["stdout"].split('\n'):
            if line.strip():
                parts = line.split('|')
                if len(parts) == 5:
                    commits.append({
                        "hash": parts[0],
                        "author": parts[1],
                        "email": parts[2],
                        "date": parts[3],
                        "message": parts[4]
                    })
        
        return commits


def version_controller_node(state: Dict[str, Any]) -> Dict[str, Any]:
    """LangGraph node for version control operations"""
    
    config = state.get("config", {})
    if not config.get("enable_git", False):
        return {
            "git_initialized": False,
            "logs": [{
                "phase": "version_control",
                "message": "Git integration disabled",
                "timestamp": state.get("timestamp")
            }]
        }
    
    controller = VersionController()
    
    if not controller.git_available:
        return {
            "git_initialized": False,
            "logs": [{
                "phase": "version_control",
                "message": "Git is not available on this system",
                "timestamp": state.get("timestamp")
            }]
        }
    
    try:
        project_id = state.get("project_id", "unknown")
        project_path = Path("artifacts") / project_id
        
        # Initialize repository
        init_result = controller.initialize_repository(project_path)
        
        if not init_result["success"]:
            return {
                "git_initialized": False,
                "logs": [{
                    "phase": "version_control",
                    "message": f"Failed to initialize Git: {init_result.get('error')}",
                    "timestamp": state.get("timestamp")
                }]
            }
        
        # Create initial commit
        commit_result = controller.create_initial_commit(project_path)
        
        # Optional: Create GitHub repo and push
        github_enabled = config.get("create_github_repo", False)
        github_pushed = False
        
        if github_enabled:
            github_token = config.get("github_token")
            repo_name = state.get("requirements", {}).get("project_name", project_id)
            
            if github_token:
                create_result = controller.create_github_repo(
                    repo_name,
                    description=f"Generated by Autonomous Deep AI Agent",
                    private=config.get("github_private", False),
                    github_token=github_token
                )
                
                if create_result["success"]:
                    # Add remote and push
                    remote_url = f"https://github.com/{repo_name}.git"
                    controller.add_remote(project_path, "origin", remote_url)
                    push_result = controller.push_to_remote(project_path)
                    github_pushed = push_result["success"]
        
        return {
            "git_initialized": True,
            "git_committed": commit_result["success"],
            "github_pushed": github_pushed,
            "repository_path": str(project_path),
            "logs": [{
                "phase": "version_control",
                "message": f"Git repository initialized and committed{' (pushed to GitHub)' if github_pushed else ''}",
                "timestamp": state.get("timestamp")
            }]
        }
    
    except Exception as e:
        logger.error(f"Version control node error: {e}")
        return {
            "git_initialized": False,
            "logs": [{
                "phase": "version_control",
                "message": f"Version control failed: {str(e)}",
                "timestamp": state.get("timestamp")
            }],
            "errors": state.get("errors", []) + [str(e)]
        }
